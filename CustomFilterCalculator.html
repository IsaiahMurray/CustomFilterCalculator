<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Custom Filter Calculator</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            text-align: center;
        }
        input {
            margin: 5px;
            padding: 8px;
            font-size: 16px;
        }
        button {
            padding: 10px;
            font-size: 16px;
            background-color: #28a745;
            color: white;
            border: none;
            cursor: pointer;
        }
        button:hover {
            background-color: #218838;
        }
        table {
            width: 80%;
            margin: 20px auto;
            border-collapse: collapse;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 10px;
        }
        th {
            background-color: #007bff;
            color: white;
        }
    </style>
</head>
<body>

    <h2>Custom Filter Size Calculator</h2>
    <label>Target Size (LxWxH):</label>
    <input type="text" id="targetSize" placeholder="e.g., 9.25x47.25x1">
    <label>Quantity:</label>
    <input type="number" id="quantity" placeholder="e.g., 10" min="1">
    <button onclick="calculateFilters()">Find Filters</button>

    <h3>Results</h3>
    <table id="resultsTable">
        <thead>
            <tr>
                <th>Target Size</th>
                <th>Quantity</th>
                <th>Used Filters</th>
                <th>Assembly Orientation</th>
                <th>Cost</th>
                <th>Trim Area</th>
                <th>Details</th>
            </tr>
        </thead>
        <tbody id="resultsBody">
            <!-- Results will be inserted here -->
        </tbody>
    </table>

    <script>
        async function fetchFilters() {
            const response = await fetch('filters.json');
            return response.json();
        }

        function parseSize(sizeString) {
            const [length, width, height] = sizeString.split("x").map(Number);
            return { length, width, height };
        }

        function calculateTrimArea(combinedLength, combinedWidth, target) {
            const combinedArea = combinedLength * combinedWidth;
            const targetArea = target.length * target.width;
            return Math.max(combinedArea - targetArea, 0);
        }

        function canCutAndCombine(filter, target) {
            const targetLongSide = Math.max(target.length, target.width);
            const targetShortSide = Math.min(target.length, target.width);

            if (filter.length * 2 >= targetLongSide && filter.width / 2 >= targetShortSide) {
                return { possible: true, newSize: { length: filter.length * 2, width: filter.width / 2 }, count: 2 };
            }
            if (filter.width * 2 >= targetLongSide && filter.length / 2 >= targetShortSide) {
                return { possible: true, newSize: { length: filter.length / 2, width: filter.width * 2 }, count: 2 };
            }
            return null;
        }

        async function calculateFilters() {
            const targetSize = document.getElementById("targetSize").value;
            const quantity = parseInt(document.getElementById("quantity").value);

            if (!targetSize || isNaN(quantity) || quantity < 1) {
                alert("Please enter a valid target size and quantity.");
                return;
            }

            const target = parseSize(targetSize);
            const filters = await fetchFilters();
            const combinations = [];

            filters.forEach((filter) => {
                const canCombine = canCutAndCombine(filter, target);
                if (canCombine && canCombine.possible) {
                    const { newSize, count } = canCombine;
                    const totalFiltersNeeded = Math.ceil(quantity / count);
                    const trimArea = calculateTrimArea(newSize.length, newSize.width, target) * totalFiltersNeeded;

                    combinations.push({
                        targetSize: `${target.length}x${target.width}x${target.height}`,
                        quantity,
                        filters: [filter.filterID],
                        assemblyOrientation: filter.orientation,
                        cost: filter.price * totalFiltersNeeded,
                        trimArea,
                        dimensionDetails: `Use ${totalFiltersNeeded}x ${filter.filterID}, cut in half and combine to make ${newSize.length}x${newSize.width}, then trim to target size`
                    });
                }
            });

            displayResults(combinations);
        }

        function displayResults(combinations) {
            const resultsBody = document.getElementById("resultsBody");
            resultsBody.innerHTML = ""; // Clear previous results

            if (combinations.length === 0) {
                resultsBody.innerHTML = `<tr><td colspan="7">‚ùå No valid combinations found.</td></tr>`;
                return;
            }

            combinations.sort((a, b) => a.cost - b.cost).slice(0, 6).forEach(combo => {
                const row = document.createElement("tr");
                row.innerHTML = `
                    <td>${combo.targetSize}</td>
                    <td>${combo.quantity}</td>
                    <td>${combo.filters.join(", ")}</td>
                    <td>${combo.assemblyOrientation}</td>
                    <td>$${combo.cost.toFixed(2)}</td>
                    <td>${combo.trimArea} sq in</td>
                    <td>${combo.dimensionDetails}</td>
                `;
                resultsBody.appendChild(row);
            });
        }
    </script>

</body>
</html>
